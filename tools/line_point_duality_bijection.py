#!/usr/bin/env python3
"""Construct a line->point duality and edge->phase mapping via group action.

Pure-python (no sympy). Generates PSp(4,3) by BFS on generator permutations.
"""

from __future__ import annotations

import json
from collections import deque
from itertools import combinations, product
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]


def build_projective_points():
    F3 = [0, 1, 2]
    proj_points = []
    seen = set()
    for v in product(F3, repeat=4):
        if all(x == 0 for x in v):
            continue
        v = list(v)
        for i in range(4):
            if v[i] != 0:
                inv = 1 if v[i] == 1 else 2
                v = tuple((x * inv) % 3 for x in v)
                break
        if v not in seen:
            seen.add(v)
            proj_points.append(v)
    return proj_points


def omega_sym(x, y):
    return (x[0] * y[2] - x[2] * y[0] + x[1] * y[3] - x[3] * y[1]) % 3


def build_edges(proj_points):
    edges = []
    for i in range(40):
        for j in range(i + 1, 40):
            if omega_sym(proj_points[i], proj_points[j]) == 0:
                edges.append((i, j))
    return edges


def build_lines_from_edges(edges):
    adj = [[0] * 40 for _ in range(40)]
    for i, j in edges:
        adj[i][j] = adj[j][i] = 1

    lines = set()
    for i, j in edges:
        common = [k for k in range(40) if adj[i][k] and adj[j][k]]
        if len(common) == 2:
            line = tuple(sorted([i, j, common[0], common[1]]))
            lines.add(line)
    return sorted(lines)


def normalize_proj(v):
    v = list(v)
    for i in range(4):
        if v[i] != 0:
            inv = 1 if v[i] == 1 else 2
            return tuple((x * inv) % 3 for x in v)
    return tuple(v)


def check_symplectic(M):
    Omega = [[0, 0, 1, 0], [0, 0, 0, 1], [2, 0, 0, 0], [0, 2, 0, 0]]

    def mat_mult(A, B):
        n, k, m = len(A), len(B), len(B[0])
        result = [[0] * m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                for l in range(k):
                    result[i][j] = (result[i][j] + A[i][l] * B[l][j]) % 3
        return result

    MT = [[M[j][i] for j in range(4)] for i in range(4)]
    result = mat_mult(mat_mult(MT, Omega), M)
    return result == Omega


def apply_matrix(M, v):
    result = [sum(M[i][j] * v[j] for j in range(4)) % 3 for i in range(4)]
    return normalize_proj(result)


def matrix_to_vertex_perm(M, vertices):
    v_to_idx = {tuple(v): i for i, v in enumerate(vertices)}
    perm = []
    for v in vertices:
        v_new = apply_matrix(M, v)
        if v_new in v_to_idx:
            perm.append(v_to_idx[v_new])
        else:
            return None
    return perm


def perm_compose(a, b):
    """Compose permutations a âˆ˜ b (apply b then a)."""
    return [a[i] for i in b]


def perm_inverse(p):
    inv = [0] * len(p)
    for i, v in enumerate(p):
        inv[v] = i
    return inv


def get_sp43_generators(vertices):
    gen_matrices = [
        [[1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],
        [[1, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1]],
        [[1, 0, 0, 0], [0, 1, 0, 0], [1, 0, 1, 0], [0, 0, 0, 1]],
        [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]],
        [[1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 2, 1]],
        [[1, 0, 0, 0], [1, 1, 0, 0], [0, 0, 1, 2], [0, 0, 0, 1]],
        [[0, 0, 1, 0], [0, 1, 0, 0], [2, 0, 0, 0], [0, 0, 0, 1]],
        [[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 2, 0, 0]],
        [[2, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 1]],
        [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 1, 0], [0, 0, 0, 2]],
    ]
    gens = []
    for M in gen_matrices:
        if check_symplectic(M):
            perm = matrix_to_vertex_perm(M, vertices)
            if perm and perm != list(range(40)):
                gens.append(perm)
    return gens


def line_perm_from_vertex_perm(vperm, lines):
    line_to_idx = {tuple(line): i for i, line in enumerate(lines)}
    perm = []
    for line in lines:
        mapped = tuple(sorted(vperm[i] for i in line))
        perm.append(line_to_idx[mapped])
    return perm


def enumerate_group_elements(gens):
    # BFS over group generated by gens
    id_perm = list(range(len(gens[0])))
    seen = {tuple(id_perm)}
    queue = deque([id_perm])
    elems = []
    while queue:
        cur = queue.popleft()
        elems.append(cur)
        for g in gens:
            nxt = perm_compose(g, cur)
            t = tuple(nxt)
            if t not in seen:
                seen.add(t)
                queue.append(nxt)
    return elems


def stabilizer_of_line(group_elems, line):
    line_set = set(line)
    stab = []
    for g in group_elems:
        mapped = {g[i] for i in line_set}
        if mapped == line_set:
            stab.append(g)
    return stab


def fixed_points(stabilizer, n_points=40):
    fixed = []
    for p in range(n_points):
        if all(g[p] == p for g in stabilizer):
            fixed.append(p)
    return fixed


def bfs_line_words(line_gens, base_idx=0):
    labels = {base_idx: []}
    q = deque([base_idx])
    while q:
        cur = q.popleft()
        word = labels[cur]
        for gi, g in enumerate(line_gens):
            nxt = g[cur]
            if nxt not in labels:
                labels[nxt] = word + [gi]
                q.append(nxt)
            invg = perm_inverse(g)
            inv = invg[cur]
            if inv not in labels:
                labels[inv] = word + [-(gi + 1)]
                q.append(inv)
    return labels


def apply_word_to_point(word, point, point_gens):
    cur = point
    for w in word:
        if w >= 0:
            cur = point_gens[w][cur]
        else:
            gi = -w - 1
            inv = perm_inverse(point_gens[gi])
            cur = inv[cur]
    return cur


def main():
    vertices = build_projective_points()
    edges = build_edges(vertices)
    lines = build_lines_from_edges(edges)

    print(f"Points: {len(vertices)}  Lines: {len(lines)}  Edges: {len(edges)}")

    point_gens = get_sp43_generators(vertices)
    print(f"Generator count: {len(point_gens)}")

    elems = enumerate_group_elements(point_gens)
    print(f"Enumerated group elements: {len(elems)}")

    L0 = lines[0]
    stab = stabilizer_of_line(elems, L0)
    print(f"Stabilizer size (setwise) for L0: {len(stab)}")

    fixed = fixed_points(stab, n_points=40)
    print(f"Fixed points of stabilizer: {fixed}")

    if not fixed:
        print("No fixed point for base line stabilizer. Using p0=0 (non-equivariant).")
        p0 = 0
    else:
        p0 = fixed[0]
        print(f"Using fixed point p0={p0}")

    line_gens = [line_perm_from_vertex_perm(g, lines) for g in point_gens]
    line_words = bfs_line_words(line_gens, base_idx=0)
    print(f"Line words computed: {len(line_words)}")

    line_to_point = {}
    for li, word in line_words.items():
        line_to_point[li] = apply_word_to_point(word, p0, point_gens)

    print(f"Line->point image size: {len(set(line_to_point.values()))}")

    base_line = L0
    base_pairs = sorted(list(combinations(base_line, 2)))
    phase_of_pair = {pair: idx for idx, pair in enumerate(base_pairs)}

    edge_to_phase = {}
    for li, line in enumerate(lines):
        word = line_words[li]
        mapped_pts = [apply_word_to_point(word, p, point_gens) for p in base_line]
        mapped_pairs = {}
        for a, b in base_pairs:
            ia = base_line.index(a)
            ib = base_line.index(b)
            pair = tuple(sorted((mapped_pts[ia], mapped_pts[ib])))
            mapped_pairs[pair] = phase_of_pair[(a, b)]
        for pair, phase in mapped_pairs.items():
            edge_to_phase[pair] = phase

    # map edges
    edge_to_vertex = {}
    line_lookup = {line: idx for idx, line in enumerate(lines)}
    for e in edges:
        e_sorted = tuple(sorted(e))
        line_idx = next(
            i for i, line in enumerate(lines) if set(e_sorted).issubset(line)
        )
        point = line_to_point[line_idx]
        phase = edge_to_phase[e_sorted]
        edge_to_vertex[e_sorted] = (point, phase)

    used = set(edge_to_vertex.values())
    print(f"Edge->vertex mappings: {len(edge_to_vertex)}  Used vertices: {len(used)}")

    out = {
        "line_to_point": {str(k): v for k, v in line_to_point.items()},
        "edge_to_vertex": {
            f"{a}-{b}": [p, ph] for (a, b), (p, ph) in edge_to_vertex.items()
        },
        "base_line": list(base_line),
        "base_pairs": [list(p) for p in base_pairs],
        "p0": p0,
        "stabilizer_size": len(stab),
        "fixed_points": fixed,
        "used_vertices": len(used),
    }
    out_path = ROOT / "artifacts" / "line_point_duality_bijection.json"
    out_path.write_text(json.dumps(out, indent=2))
    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()
