#!/usr/bin/env python3
"""Search for relabelings of the 27 lines that homogenize triangle class patterns.

We keep the Schl채fli line set fixed but allow a permutation of the 27 lines
that preserves the Schl채fli intersection graph. This is a graph automorphism.
We test whether any automorphism makes the 9 triangles pattern-homogeneous
with respect to Coxeter pattern classes or W(E6) orbit content.

This is a heuristic randomized search over automorphisms generated by
known symmetries of the Schl채fli graph (via S6 action on indices and
E<->C swap), not full Aut(Schl채fli)=W(E6).
"""

from __future__ import annotations

import json
import random
from collections import Counter
from itertools import permutations
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]


def build_27_lines():
    lines = []
    for i in range(1, 7):
        lines.append(("E", i))
    for i in range(1, 7):
        lines.append(("C", i))
    for i in range(1, 7):
        for j in range(i + 1, 7):
            lines.append(("L", i, j))
    return lines


def lines_intersect(L1, L2):
    if L1 == L2:
        return False

    t1, t2 = L1[0], L2[0]

    if t1 == "E" and t2 == "E":
        return False
    if t1 == "C" and t2 == "C":
        return False

    if t1 == "E" and t2 == "C":
        return L1[1] != L2[1]
    if t1 == "C" and t2 == "E":
        return L1[1] != L2[1]

    if t1 == "E" and t2 == "L":
        return L1[1] in L2[1:]
    if t1 == "L" and t2 == "E":
        return L2[1] in L1[1:]

    if t1 == "C" and t2 == "L":
        return L1[1] in L2[1:]
    if t1 == "L" and t2 == "C":
        return L2[1] in L1[1:]

    if t1 == "L" and t2 == "L":
        s1 = set(L1[1:])
        s2 = set(L2[1:])
        return len(s1 & s2) == 0

    return False


def schlafli_intersection_graph(lines):
    n = len(lines)
    adj = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            if lines_intersect(lines[i], lines[j]):
                adj[i][j] = adj[j][i] = 1
    return adj


def load_triangles():
    tri_data = json.loads(
        (ROOT / "artifacts" / "h27_schlafli_leftover_cycles.json").read_text()
    )
    triangles = [[tuple(x) for x in tri] for tri in tri_data["cycle_labels"]]
    return triangles


def load_line_to_class():
    a2 = json.loads(
        (ROOT / "artifacts" / "a2_triangles_vs_coxeter_patterns.json").read_text()
    )
    line_to_class = {eval(k): v for k, v in a2["line_to_class"].items()}
    return line_to_class


def triangle_pattern(tri, line_to_class):
    return tuple(sorted(line_to_class[tuple(t)] for t in tri))


def apply_perm_to_line(line, perm, swap_ec=False):
    t = line[0]
    if t == "E":
        t2 = "C" if swap_ec else "E"
        return (t2, perm[line[1] - 1] + 1)
    if t == "C":
        t2 = "E" if swap_ec else "C"
        return (t2, perm[line[1] - 1] + 1)
    # L_{ij}
    i, j = line[1], line[2]
    i2 = perm[i - 1] + 1
    j2 = perm[j - 1] + 1
    if i2 > j2:
        i2, j2 = j2, i2
    return ("L", i2, j2)


def apply_perm_to_triangle(tri, perm, swap_ec=False):
    return [apply_perm_to_line(line, perm, swap_ec) for line in tri]


def search(num_samples=2000):
    lines = build_27_lines()
    triangles = load_triangles()
    line_to_class = load_line_to_class()

    base_patterns = [triangle_pattern(tri, line_to_class) for tri in triangles]
    base_counts = Counter(base_patterns)

    best = (len(base_counts), base_counts, None)

    for _ in range(num_samples):
        perm = list(range(6))
        random.shuffle(perm)
        swap_ec = random.choice([False, True])

        # update line classes under permutation
        line_to_class_perm = {}
        for line in lines:
            line_p = apply_perm_to_line(line, perm, swap_ec)
            line_to_class_perm[line_p] = line_to_class[line]

        # compute triangle patterns under perm
        patterns = []
        for tri in triangles:
            tri_p = apply_perm_to_triangle(tri, perm, swap_ec)
            patterns.append(triangle_pattern(tri_p, line_to_class_perm))

        counts = Counter(patterns)
        if len(counts) < best[0]:
            best = (len(counts), counts, (perm, swap_ec))

    return base_counts, best


def main():
    base_counts, best = search(num_samples=5000)
    results = {
        "base_pattern_counts": {str(k): v for k, v in base_counts.items()},
        "best_pattern_count": best[0],
        "best_pattern_counts": {str(k): v for k, v in best[1].items()},
        "best_perm": best[2],
    }

    out_path = ROOT / "artifacts" / "triangle_relabeling_search.json"
    out_path.write_text(json.dumps(results, indent=2), encoding="utf-8")
    print(results)
    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()
