#!/usr/bin/env python3
"""Analyze W(E6) action on E8 roots and connect to W33 edges.

Key question: Does W(E6) act transitively on 240 E8 roots?
If not, what are the orbits?

This will clarify the group-theoretic bijection.
"""
from __future__ import annotations

import json
from collections import Counter, defaultdict
from itertools import combinations, permutations
from pathlib import Path
import numpy as np

ROOT = Path(__file__).resolve().parents[1]


def construct_e8_roots():
    """Construct all 240 E8 roots."""
    roots = []

    # Type 1: (+-1, +-1, 0^6) permutations: 112 roots
    for i in range(8):
        for j in range(i+1, 8):
            for s1 in [1, -1]:
                for s2 in [1, -1]:
                    r = [0.0]*8
                    r[i], r[j] = s1, s2
                    roots.append(tuple(r))

    # Type 2: (+-1/2)^8 with even minus signs: 128 roots
    for bits in range(256):
        signs = [1 if (bits >> k) & 1 else -1 for k in range(8)]
        if sum(1 for s in signs if s == -1) % 2 == 0:
            roots.append(tuple(s * 0.5 for s in signs))

    return roots


def construct_e6_roots():
    """Construct E6 roots as subset of E8.

    Standard embedding: E6 roots are E8 roots orthogonal to
    v1 = (1,1,0,0,0,0,0,0) and v2 = (0,0,1,1,1,1,1,1)
    """
    e8_roots = construct_e8_roots()
    e6_roots = []

    for r in e8_roots:
        # Check orthogonality to v1 and v2
        dot1 = r[0] + r[1]
        dot2 = sum(r[2:])
        if abs(dot1) < 0.01 and abs(dot2) < 0.01:
            e6_roots.append(r)

    return e6_roots


def get_e6_simple_roots():
    """Get the simple roots of E6 in E8 embedding."""
    # Standard E6 simple roots (alpha_1 through alpha_6)
    # Using the E8 embedding where E6 is orthogonal to (1,1,0,...) and (0,0,1,1,1,1,1,1)

    # Simple roots for E6:
    # alpha_1 = (1,-1,0,0,0,0,0,0) - but this has dot1 = 0, need to check dot2
    # Actually for E6 in E8, we need 6 simple roots

    # Using Bourbaki conventions for E6 in E8:
    simple = [
        (0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5),  # modified
        (1, 1, 0, 0, 0, 0, 0, 0),  # but this has dot1 = 2, not valid
    ]

    # Let me use a different approach: take E6 roots and find simple ones
    e6_roots = construct_e6_roots()

    # For now, return E6 roots and compute reflections
    return e6_roots


def weyl_reflection(root, alpha):
    """Reflect root in hyperplane orthogonal to alpha.

    Formula: s_alpha(r) = r - 2*(r.alpha)/(alpha.alpha) * alpha
    """
    r_dot_a = sum(root[i] * alpha[i] for i in range(8))
    a_dot_a = sum(alpha[i] * alpha[i] for i in range(8))

    result = tuple(root[i] - 2 * r_dot_a / a_dot_a * alpha[i] for i in range(8))
    return result


def normalize_root(r, tol=1e-6):
    """Normalize root to standard form for hashing."""
    # Round to avoid floating point issues
    return tuple(round(x, 6) for x in r)


def compute_weyl_orbit(start_root, generators, max_size=1000):
    """Compute orbit of start_root under Weyl reflections."""
    orbit = {normalize_root(start_root)}
    frontier = [start_root]

    while frontier and len(orbit) < max_size:
        current = frontier.pop()
        for gen in generators:
            reflected = weyl_reflection(current, gen)
            norm = normalize_root(reflected)
            if norm not in orbit:
                orbit.add(norm)
                frontier.append(reflected)

    return orbit


def analyze_e6_orbits_on_e8():
    """Analyze how W(E6) acts on E8 roots."""
    print("=" * 70)
    print("W(E6) ACTION ON E8 ROOTS")
    print("=" * 70)

    e8_roots = construct_e8_roots()
    e6_roots = construct_e6_roots()

    print(f"\nE8: {len(e8_roots)} roots")
    print(f"E6: {len(e6_roots)} roots (subset of E8)")

    # The E6 roots serve as generators for W(E6)
    # W(E6) is generated by reflections in the simple roots of E6

    # For simplicity, use ALL E6 roots as potential reflection generators
    # (This is overkill but correct)

    # Compute orbit of a single E8 root under W(E6)
    test_roots = [
        e8_roots[0],   # A type-1 root
        e8_roots[112],  # A type-2 root (half-integer)
    ]

    root_set = set(normalize_root(r) for r in e8_roots)

    for test in test_roots:
        print(f"\n--- Testing root: {test}")

        # Compute orbit under E6 reflections
        orbit = compute_weyl_orbit(test, e6_roots, max_size=250)
        orbit_in_e8 = orbit & root_set

        print(f"  Orbit size under W(E6): {len(orbit)}")
        print(f"  Orbit intersection with E8 roots: {len(orbit_in_e8)}")

    # More systematic: partition E8 roots by E6 orbit
    print("\n" + "-" * 50)
    print("PARTITIONING E8 ROOTS BY W(E6) ORBITS")
    print("-" * 50)

    # Use representatives from each orbit
    remaining = set(normalize_root(r) for r in e8_roots)
    orbits = []

    while remaining:
        # Take any remaining root
        rep = next(iter(remaining))
        rep_tuple = tuple(float(x) for x in rep)

        # Compute its orbit
        orbit = compute_weyl_orbit(rep_tuple, e6_roots, max_size=250)
        orbit_normalized = {normalize_root(r) for r in orbit if normalize_root(r) in remaining}

        orbits.append(orbit_normalized)
        remaining -= orbit_normalized

        if len(orbits) > 10:
            print("Too many orbits, something is wrong")
            break

    print(f"\nNumber of W(E6) orbits on E8 roots: {len(orbits)}")
    print(f"Orbit sizes: {[len(o) for o in orbits]}")

    return orbits


def compute_sp43_edge_orbits():
    """Verify that PSp(4,3) acts transitively on W33 edges."""
    print("\n" + "=" * 70)
    print("PSp(4,3) ACTION ON W33 EDGES (from earlier)")
    print("=" * 70)

    # We already computed this: PSp(4,3) has order 25920 and acts
    # transitively on 240 edges (single orbit)

    print("""
From orbit_bijection.py:
- PSp(4,3) order: 25920
- Edge orbits: [240] (single orbit of size 240)

Key insight: PSp(4,3) acts TRANSITIVELY on 240 edges!
""")


def find_bijection_strategy():
    """Determine the correct bijection strategy."""
    print("\n" + "=" * 70)
    print("BIJECTION STRATEGY")
    print("=" * 70)

    print("""
GROUPS AND ACTIONS:
1. W(E6) has order 51840
2. Sp(4,3) has order 51840
3. PSp(4,3) = Sp(4,3)/{+/-I} has order 25920
4. PSp(4,3) is isomorphic to W(E6)/center, but W(E6) center is trivial!

RESOLUTION:
W(E6) ~ Sp(4,3), not PSp(4,3).
The group we computed acting on PG(3,3) is PSp(4,3) of order 25920.
This is an INDEX 2 subgroup of the full W(E6).

FOR THE BIJECTION:
- If W(E6) has 2 orbits on E8 roots (sizes a, b with a+b=240)
- And PSp(4,3) has 1 orbit on W33 edges (size 240)
- Then the bijection combines the two W(E6) orbits into one PSp(4,3) orbit

Alternatively:
- The 240 W33 edges might correspond to a DIFFERENT 240-element W(E6) set
- Not the E8 roots themselves, but derived from them
""")


def check_alternative_240_sets():
    """Look for other 240-element sets related to E6/E8."""
    print("\n" + "=" * 70)
    print("ALTERNATIVE 240-ELEMENT SETS")
    print("=" * 70)

    e8_roots = construct_e8_roots()
    e6_roots = construct_e6_roots()

    print(f"E8 roots: {len(e8_roots)}")
    print(f"E6 roots: {len(e6_roots)}")

    # Positive roots
    e8_positive = [r for r in e8_roots if any(x > 0.01 for x in r) and
                   (r[0] > 0.01 or (r[0] == 0 and r[1] > 0.01) or
                    (r[0] == 0 and r[1] == 0 and any(x > 0.01 for x in r)))]
    print(f"E8 positive roots: {len(e8_positive)} (should be 120)")

    # E8 root pairs (root, -root)
    print(f"E8 root pairs: {len(e8_roots)//2} = 120")

    # E6 acts on E8/E7 etc
    # W(E6) order 51840 = 2^7 * 3^4 * 5

    # 51840 / 240 = 216 (stabilizer order for transitive action)
    # 51840 / 120 = 432
    # 51840 / 72 = 720

    print("\nPossible orbit sizes for W(E6) action:")
    for n in [72, 120, 240]:
        stab = 51840 // n
        print(f"  {n} elements: stabilizer order {stab}")

    # The 240 edges have PSp(4,3) stabilizer of order 25920/240 = 108
    print(f"\nPSp(4,3) edge stabilizer: 25920/240 = {25920//240}")


def main():
    # Analyze orbits
    orbits = analyze_e6_orbits_on_e8()

    # Compare with W33
    compute_sp43_edge_orbits()

    # Strategy
    find_bijection_strategy()

    # Alternatives
    check_alternative_240_sets()

    # Save results
    results = {
        "e6_orbits_on_e8": [len(o) for o in orbits],
        "psp43_edge_orbits": [240],
        "conclusion": "W(E6) has multiple orbits on E8, PSp(4,3) is transitive on edges"
    }

    out_path = ROOT / "artifacts" / "weyl_e6_action.json"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(results, indent=2), encoding='utf-8')
    print(f"\n\nWrote {out_path}")


if __name__ == "__main__":
    main()
