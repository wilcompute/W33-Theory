#!/usr/bin/env python3
"""Test invariance of overlap-phase classes under monomial symmetries.

We consider the monomial group generated by:
  - coordinate permutations (S4)
  - coordinate-wise cube-root phases (Z3^4)
We keep only elements that permute the 40-ray set (projectively), using
direct complex matching up to global phase.
Then we measure how often phase classes of non-orthogonal pairs
are preserved under these symmetries.
"""
from __future__ import annotations

import json
import itertools
from collections import Counter
from pathlib import Path

import numpy as np

ROOT = Path(__file__).resolve().parents[1]


def construct_witting_40_rays():
    omega = np.exp(2j * np.pi / 3)
    sqrt3 = np.sqrt(3)
    rays = []
    for i in range(4):
        v = np.zeros(4, dtype=complex)
        v[i] = 1
        rays.append(v)
    for mu in range(3):
        for nu in range(3):
            rays.append(np.array([0, 1, -omega**mu, omega**nu]) / sqrt3)
            rays.append(np.array([1, 0, -omega**mu, -omega**nu]) / sqrt3)
            rays.append(np.array([1, -omega**mu, 0, omega**nu]) / sqrt3)
            rays.append(np.array([1, omega**mu, omega**nu, 0]) / sqrt3)
    return rays


def canonical_key(ray, tol=1e-6):
    """Normalize by global phase (first nonzero entry to 1) and round."""
    idx = None
    for i, z in enumerate(ray):
        if abs(z) > tol:
            idx = i
            break
    if idx is None:
        return None
    ray_n = ray / ray[idx]
    # round real/imag to stabilize key
    key = tuple((round(float(z.real), 6), round(float(z.imag), 6)) for z in ray_n)
    return key


def phase_class(angle):
    a = np.arctan2(np.sin(angle), np.cos(angle))
    # round to 6 decimals for class
    return round(float(a), 6)


def main():
    rays = construct_witting_40_rays()
    n = len(rays)
    # precompute phase class for each non-orthogonal pair
    pair_phase = {}
    for i in range(n):
        for j in range(i + 1, n):
            ip = np.vdot(rays[i], rays[j])
            if abs(ip) < 1e-8:
                continue
            pair_phase[(i, j)] = phase_class(np.angle(ip))

    # build monomial group elements: permutations + phase shifts in Z3^4
    omega = np.exp(2j * np.pi / 3)
    phases = [0, 1, 2]
    elements = []
    # precompute ray keys for matching
    ray_key = [canonical_key(r) for r in rays]
    key_to_idx = {k: i for i, k in enumerate(ray_key)}

    for perm in itertools.permutations(range(4)):
        for a0, a1, a2, a3 in itertools.product(phases, repeat=4):
            phase_vec = np.array([omega**a0, omega**a1, omega**a2, omega**a3], dtype=complex)
            mapping = []
            valid = True
            for r in rays:
                v = r[list(perm)] * phase_vec
                key = canonical_key(v)
                if key not in key_to_idx:
                    valid = False
                    break
                mapping.append(key_to_idx[key])
            if valid:
                elements.append(mapping)

    # Evaluate invariance of pair phase classes
    total_pairs = len(pair_phase)
    invariance_counts = Counter()
    for mapping in elements:
        changed = 0
        for (i, j), ph in pair_phase.items():
            ii = mapping[i]
            jj = mapping[j]
            if ii == jj:
                continue
            a, b = (ii, jj) if ii < jj else (jj, ii)
            ph2 = pair_phase.get((a, b))
            if ph2 is None:
                # mapped to orthogonal pair
                changed += 1
            elif ph2 != ph:
                changed += 1
        invariance_counts[changed] += 1

    out = {
        "group_elements": len(elements),
        "pairs": total_pairs,
        "change_counts": {str(k): v for k, v in sorted(invariance_counts.items())},
    }

    out_path = ROOT / "artifacts" / "witting_phase_orbit_invariance.json"
    out_path.write_text(json.dumps(out, indent=2), encoding="utf-8")

    md_path = ROOT / "docs" / "witting_phase_orbit_invariance.md"
    with md_path.open("w", encoding="utf-8") as f:
        f.write("# Phase‑class Invariance under Monomial Symmetries\n\n")
        f.write(f"Group elements preserving the 40‑ray set: **{len(elements)}**\n\n")
        f.write(f"Non‑orthogonal pairs: **{total_pairs}**\n\n")
        f.write("## Pair phase‑class change counts per symmetry\n\n")
        f.write("changed pairs | symmetries\n")
        f.write("--- | ---\n")
        for k, v in sorted(invariance_counts.items()):
            f.write(f"{k} | {v}\n")
    print(f"Wrote {out_path}")
    print(f"Wrote {md_path}")


if __name__ == "__main__":
    main()
