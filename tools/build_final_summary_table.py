#!/usr/bin/env python3
"""Build the FINAL_THEORY_SUMMARY prediction tables from fixed formulas.

This script produces:
- artifacts/final_summary_table.md
- artifacts/final_summary_table.json

All experimental comparison values are the ones embedded in FINAL_THEORY_SUMMARY.md
(as of 2026-01-25) so the table is internally consistent with the document.
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from math import sqrt
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
OUT_MD = ROOT / "artifacts" / "final_summary_table.md"
OUT_JSON = ROOT / "artifacts" / "final_summary_table.json"

# Fixed inputs (document-era values)
V = 246.22  # Higgs VEV in GeV


# Helper structures
@dataclass
class Entry:
    tier: str
    quantity: str
    formula: str
    predicted: float | str
    experimental: float | str | None
    unit: str | None = None

    def error_pct(self) -> float | None:
        if self.experimental is None or isinstance(self.experimental, str):
            return None
        if isinstance(self.predicted, str):
            return None
        if self.experimental == 0:
            return None
        return abs(self.predicted - self.experimental) / abs(self.experimental) * 100

    def error_ppb(self) -> float | None:
        if self.experimental is None or isinstance(self.experimental, str):
            return None
        if isinstance(self.predicted, str):
            return None
        if self.experimental == 0:
            return None
        return abs(self.predicted - self.experimental) / abs(self.experimental) * 1e9


def fmt_num(value: float | str | None, unit: str | None = None, digits: int = 6) -> str:
    if value is None:
        return "—"
    if isinstance(value, str):
        return value
    if abs(value) >= 1000:
        s = f"{value:.3g}"
    else:
        s = f"{value:.{digits}g}"
    if unit:
        return f"{s} {unit}"
    return s


# Core derived values
alpha_inv = 81 + 56 + 40 / (1080 + 31 + 1 / 7)
alpha = 1 / alpha_inv
sin2_theta_w = 40 / 173
alpha_s = 8 / 68
sin2_theta_12 = 27 / 89
sin2_theta_23 = 78 / 173
sin2_theta_13 = 8 / 360
m_t = V * sqrt(40 / 81)
m_h = (V / 2) * sqrt(81 / 78)
m_tau = V * alpha * (89 / 90)
m_mu = m_tau / 17
m_e = m_mu / 208
m_c = m_t * alpha
m_s = m_c / 14
m_b = m_tau * (7 / 3)
m_d = m_s / 20
sin_delta_ckm = 40 / 43
dm2_ratio = 1 / 31

# Tier definitions
entries: list[Entry] = [
    Entry(
        "Tier 1",
        "alpha^-1",
        "81 + 56 + 40/(1080+31+1/7)",
        alpha_inv,
        137.035999084,
        None,
    ),
    Entry("Tier 1", "sin^2 theta_W", "40/173", sin2_theta_w, 0.2312, None),
    Entry("Tier 1", "alpha_s", "8/68", alpha_s, 0.1179, None),
    Entry("Tier 1", "sin^2 theta_12", "27/89", sin2_theta_12, 0.3032, None),
    Entry("Tier 1", "sin^2 theta_23", "78/173", sin2_theta_23, 0.4512, None),
    Entry("Tier 1", "m_t", "v*sqrt(40/81)", m_t, 172.7, "GeV"),
    Entry("Tier 1", "m_H", "(v/2)*sqrt(81/78)", m_h, 125.3, "GeV"),
    Entry("Tier 1", "m_tau", "v*alpha*(89/90)", m_tau, 1.777, "GeV"),
    Entry("Tier 1", "m_c", "m_t*alpha", m_c, 1.27, "GeV"),
    Entry("Tier 1", "m_b", "m_tau*(7/3)", m_b, 4.18, "GeV"),
    Entry("Tier 1", "m_d", "m_s/20", m_d, 4.7e-3, "GeV"),
    Entry("Tier 1", "m_mu", "m_tau/17", m_mu, 105.7e-3, "GeV"),
    Entry("Tier 1", "m_e", "m_mu/208", m_e, 0.511e-3, "GeV"),
    Entry("Tier 1", "sin(delta_CKM)", "40/43", sin_delta_ckm, 0.927, None),
    Entry("Tier 1", "Delta m^2_21 / Delta m^2_31", "1/31", dm2_ratio, 0.031, None),
    Entry("Tier 2", "sin^2 theta_13", "8/360", sin2_theta_13, 0.0225, None),
    Entry("Tier 2", "lambda (CKM)", "sqrt(2/40)", sqrt(2 / 40), 0.226, None),
    Entry("Tier 2", "A (CKM)", "31/40", 31 / 40, 0.790, None),
    Entry("Tier 2", "m_s", "m_c/14", m_s, 93e-3, "GeV"),
    Entry("Tier 2", "m_u", "m_c*alpha/4", m_c * alpha / 4, 2.2e-3, "GeV"),
    Entry("Tier 3", "N_generations", "81/27", 81 / 27, 3, None),
    Entry("Tier 3", "Omega_DM / Omega_b", "27/5", 27 / 5, 5.4, None),
    Entry("Tier 3", "D (M-theory dims)", "sqrt(121)", sqrt(121), 11, None),
    Entry("Tier 3", "Mass ordering", "PMNS hierarchy", "Normal", "TBD", None),
    Entry("Tier 4", "M_Pl / v", "3^36", 3**36, 5e16, None),
    Entry("Tier 4", "rho_Lambda / M_Pl^4", "3^-256", 3**-256, 1e-123, None),
]

# Build markdown tables by tier
order = ["Tier 1", "Tier 2", "Tier 3", "Tier 4"]
lines: list[str] = []


# JSON output
json_data = {
    "generated_at": "2026-01-26",
    "vev_GeV": V,
    "entries": [
        {
            "tier": e.tier,
            "quantity": e.quantity,
            "formula": e.formula,
            "predicted": e.predicted,
            "experimental": e.experimental,
            "unit": e.unit,
            "error_pct": e.error_pct(),
            "error_ppb": e.error_ppb(),
        }
        for e in entries
    ],
}


def main():
    lines.append("# FINAL THEORY SUMMARY — COMPUTED TABLES")
    lines.append("")
    lines.append(
        "Generated by `tools/build_final_summary_table.py` using the formulas and comparison values embedded in FINAL_THEORY_SUMMARY.md (Jan 25, 2026)."
    )
    lines.append("")
    for tier in order:
        tier_entries = [e for e in entries if e.tier == tier]
        if not tier_entries:
            continue
        lines.append(f"## {tier}")
        lines.append("")
        lines.append("| Quantity | W33 Formula | Predicted | Experimental | Error |")
        lines.append("|---|---|---|---|---|")
        for e in tier_entries:
            if e.quantity == "alpha^-1":
                err = e.error_ppb()
                err_str = f"{err:.2f} ppb" if err is not None else "—"
            else:
                err = e.error_pct()
                err_str = f"{err:.2f}%" if err is not None else "—"
            pred = fmt_num(e.predicted, e.unit)
            exp = fmt_num(e.experimental, e.unit)
            lines.append(f"| {e.quantity} | {e.formula} | {pred} | {exp} | {err_str} |")
        lines.append("")
    OUT_MD.parent.mkdir(parents=True, exist_ok=True)
    OUT_MD.write_text("\n".join(lines), encoding="utf-8")
    OUT_JSON.write_text(json.dumps(json_data, indent=2), encoding="utf-8")
    print(f"Wrote {OUT_MD}")
    print(f"Wrote {OUT_JSON}")


if __name__ == "__main__":
    main()
