from __future__ import annotations

from collections import deque
from dataclasses import dataclass
from typing import Dict, Iterable, List, Sequence, Set, Tuple

Perm = Tuple[int, ...]  # one-line notation: p[i] = image of i


def identity(n: int) -> Perm:
    return tuple(range(n))


def compose(p: Perm, q: Perm) -> Perm:
    """Return p âˆ˜ q (apply q first, then p)."""
    if len(p) != len(q):
        raise ValueError("Permutation lengths differ")
    return tuple(p[q[i]] for i in range(len(p)))


def inverse(p: Perm) -> Perm:
    inv = [0] * len(p)
    for i, j in enumerate(p):
        inv[j] = i
    return tuple(inv)


@dataclass(frozen=True)
class PermutationGroup:
    n: int
    generators: Tuple[Perm, ...]

    def closure(self, max_size: int | None = None) -> List[Perm]:
        """Enumerate the subgroup generated by `generators`.

        This is a straightforward BFS closure suitable for small/medium groups.
        If `max_size` is set, stops once the group reaches that size.
        """

        gens = [g for g in self.generators]
        # include inverses to speed closure
        gens.extend([inverse(g) for g in self.generators])

        e = identity(self.n)
        seen: Dict[Perm, int] = {e: 0}
        q = deque([e])

        while q:
            cur = q.popleft()
            for g in gens:
                nxt = compose(g, cur)
                if nxt in seen:
                    continue
                seen[nxt] = len(seen)
                q.append(nxt)
                if max_size is not None and len(seen) >= max_size:
                    return list(seen.keys())

        return list(seen.keys())

    def orbits(
        self, elements: Sequence[int], *, max_size: int | None = None
    ) -> List[List[int]]:
        group = self.closure(max_size=max_size)
        unassigned: Set[int] = set(elements)
        out: List[List[int]] = []

        while unassigned:
            seed = next(iter(unassigned))
            orb = set()
            for g in group:
                orb.add(g[seed])
            for x in orb:
                unassigned.discard(x)
            out.append(sorted(orb))

        return out
