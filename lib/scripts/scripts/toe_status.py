#!/usr/bin/env python
import json
import os
from pathlib import Path


ROOT = Path(__file__).resolve().parents[1]


def load_json(path: Path):
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def fmt_list(items):
    return ", ".join(str(x) for x in items)


def section(title, lines):
    return ["## " + title, *lines, ""]


def main():
    out_lines = [
        "# TOE status (derived from checkpoint JSONs)",
        "",
        "This file is generated by `scripts/toe_status.py` from JSON checkpoints only.",
        "",
    ]

    # 1) Incidence autgroup
    p = ROOT / "data/_is/incidence_autgroup_20260110/checkpoint_autgroup_20260110.json"
    if p.exists():
        d = load_json(p)
        key = d.get("key_results", {})
        out_lines += section(
            "Incidence autgroup (12 points / 15 lines)",
            [
                f"- aut_group_order: {key.get('aut_group_order')}",
                f"- distinguished_point: {key.get('distinguished_point')}",
                f"- generator_names: {fmt_list(key.get('generator_names', []))}",
                f"- degree_spectrum: {key.get('degree_spectrum')}",
            ],
        )

    # 2) Tomotope best-fit to projective classes
    p = ROOT / "data/_checkpoints/checkpoint_tomotope_to_n12_58_projective_bestfit_20260110t043900z.json"
    if p.exists():
        d = load_json(p)
        opt = d.get("optimization", {})
        out_lines += section(
            "Tomotope to projective best-fit",
            [
                f"- best_score: {opt.get('best_score')}",
                f"- matched_triangles: {opt.get('matched_triangles')}",
                f"- unmatched_triangles: {fmt_list(opt.get('unmatched_triangles', []))}",
                f"- key_hits: {opt.get('key_hits')}",
            ],
        )

    # 3) Triangle to W33 completion
    p = ROOT / "data/_checkpoints/checkpoint_tomotope_triangle_to_w33_completion_20260110t043900z.json"
    if p.exists():
        d = load_json(p)
        notes = d.get("notes", {})
        out_lines += section(
            "Tomotope triangle -> W33 completion",
            [
                f"- matched_triangles: {notes.get('matched_triangles')}",
                f"- unmatched_triangle: {notes.get('unmatched_triangle')}",
                f"- key_wedge_lines: {notes.get('key_wedge_lines')}",
            ],
        )

    # 4) Toe coupling
    p = ROOT / "data/_toe/coupling_20260110/checkpoint_toe_coupling_20260110.json"
    if p.exists():
        d = load_json(p)
        notes = d.get("notes", {})
        out_lines += section(
            "TOE coupling (2T transport)",
            [
                f"- delta4_edges: {fmt_list(notes.get('delta4_edges', []))}",
                f"- unique_edge_elems: {fmt_list(notes.get('unique_edge_elems', []))}",
            ],
        )

    # 5) Flux toggle node0 (checkpoint only)
    p = ROOT / "data/_toe/flux_toggle_node0_20260110/checkpoint_toe_flux_toggle_node0_20260110.json"
    if p.exists():
        d = load_json(p)
        files = d.get("files", {})
        out_lines += section(
            "Flux toggle (node0) artifacts",
            [
                f"- file_count: {len(files)}",
                f"- files: {fmt_list(sorted(files.keys()))}",
            ],
        )

    # 6) Take it all the way
    p = ROOT / "data/_toe/take_it_all_way_20260110/checkpoint_toe_take_it_all_way_20260110.json"
    if p.exists():
        d = load_json(p)
        files = d.get("files", {})
        out_lines += section(
            "Take it all the way (D6/D8 closure)",
            [
                f"- file_count: {len(files)}",
                f"- files: {fmt_list(sorted(files.keys()))}",
            ],
        )

    # 7) W33 orthonormal solution report
    p = ROOT / "data/_toe/w33_orthonormal_phase_solution_20260110/W33_orthonormal_solution_report.json"
    if p.exists():
        d = load_json(p)
        out_lines += section(
            "W33 orthonormal solution report",
            [
                f"- max_line_orthonormality_error: {d.get('max_line_orthonormality_error')}",
                f"- nonorth_absip2_min: {d.get('nonorth_absip2_min')}",
                f"- nonorth_absip2_max: {d.get('nonorth_absip2_max')}",
                f"- counts: {d.get('counts')}",
            ],
        )

    # 8) Orbit-0 cocycle summary
    p = ROOT / "data/_toe/geometric_reduction_20260110/orbit0_cocycle_summary.json"
    if p.exists():
        d = load_json(p)
        out_lines += section(
            "Orbit-0 cocycle summary",
            [
                f"- n_nodes: {d.get('n_nodes')}",
                f"- n_edges: {d.get('n_edges')}",
                f"- n_defect_edges: {d.get('n_defect_edges')}",
                f"- cycle_space_dim: {d.get('cycle_space_dim')}",
                f"- n_chords_with_odd_parity: {d.get('n_chords_with_odd_parity')}",
            ],
        )

    # 9) Harmonic lift checkpoint (file manifest)
    p = ROOT / "data/_toe/harmonic_lift_geometry_predictor_20260110/checkpoint_harmonic_lift_geometry_predictor.json"
    if p.exists():
        d = load_json(p)
        files = d.get("files", {})
        out_lines += section(
            "Harmonic lift geometry predictor (files)",
            [
                f"- file_count: {len(files)}",
                f"- files: {fmt_list(sorted(files.keys()))}",
            ],
        )

    # 10) Domain-wall sensors summary
    p = ROOT / "data/_toe/domainwall_to_w33_sensors_20260110/summary.json"
    if p.exists():
        d = load_json(p)
        out_lines += section(
            "Domain-wall to W33 sensors",
            [
                f"- mincut_nondefect_cost: {d.get('mincut_nondefect_cost')}",
                f"- top10_lines: {fmt_list(d.get('top10_lines', []))}",
                f"- top10_low_class_hits: {d.get('top10_low_class_hits')}",
                f"- top10_mid_class_hits: {d.get('top10_mid_class_hits')}",
            ],
        )

    # 11) Native C24 projectors
    p = ROOT / "data/_toe/native_w33_projectors_c24_20260110/checkpoint_native_C24_projectors_20260110.json"
    if p.exists():
        d = load_json(p)
        out_lines += section(
            "Native C24 projectors",
            [
                f"- uvec_definition: {d.get('uvec_definition')}",
                f"- param_points: {fmt_list(d.get('param_points', []))}",
                f"- created_files_count: {len(d.get('created_files', []))}",
            ],
        )

    # 12) Native C24 full-grid
    p = ROOT / "data/_toe/native_fullgrid_20260110/checkpoint_nativeC24_fullgrid_20260110.json"
    if p.exists():
        d = load_json(p)
        notes = d.get("notes", {})
        grid = d.get("grid", {})
        out_lines += section(
            "Native C24 full-grid",
            [
                f"- winner_changed_count: {notes.get('winner_changed_count')}",
                f"- lambda_min: {grid.get('lambda_min')}",
                f"- lambda_max: {grid.get('lambda_max')}",
                f"- lambda_step: {grid.get('lambda_step')}",
                f"- mu: {fmt_list(grid.get('mu', []))}",
            ],
        )

    out_path = ROOT / "data/_docs/toe_status.md"
    out_path.write_text("\n".join(out_lines).rstrip() + "\n", encoding="utf-8")
    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()

