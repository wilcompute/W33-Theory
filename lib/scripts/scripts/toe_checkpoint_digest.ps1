$ErrorActionPreference = "Stop"

$root = Split-Path -Parent $PSScriptRoot
$dataRoot = Join-Path $root "data"

function Short([string]$s, [int]$max = 220) {
    if ([string]::IsNullOrEmpty($s)) { return "" }
    if ($s.Length -le $max) { return $s }
    return $s.Substring(0, $max) + "..."
}

function Format-Value($value) {
    if ($null -eq $value) { return "" }
    if ($value -is [string]) { return Short $value }
    if ($value -is [System.Collections.IEnumerable] -and -not ($value -is [string])) {
        $arr = @($value)
        if ($arr.Count -le 10) {
            return Short (($arr | ForEach-Object { $_.ToString() }) -join ", ")
        }
        return "count=$($arr.Count)"
    }
    try {
        return Short ($value | ConvertTo-Json -Compress -Depth 6)
    } catch {
        return Short ($value.ToString())
    }
}

function Get-Json([string]$path) {
    try {
        return Get-Content -Path $path -Raw | ConvertFrom-Json
    } catch {
        return $null
    }
}

function Get-Timestamp($obj) {
    foreach ($key in @("timestamp_utc","created_utc","generated_utc","timestamp","created","generated","generated_utc")) {
        if ($obj.PSObject.Properties.Name -contains $key) {
            $val = $obj.$key
            if ($val) { return $val }
        }
    }
    return ""
}

function Summarize-Json([string]$path, [string]$relative) {
    $obj = Get-Json $path
    if ($null -eq $obj) {
        return @(
            "### $relative",
            "- parse_error: true",
            ""
        )
    }

    $lines = @("### $relative")

    $timestamp = Get-Timestamp $obj
    if ($timestamp) { $lines += "- timestamp: $timestamp" }

    foreach ($key in @("purpose","summary","notes","key_results","results","observations","status")) {
        if ($obj.PSObject.Properties.Name -contains $key) {
            $val = Format-Value $obj.$key
            if ($val) { $lines += "- ${key}: $val" }
        }
    }

    foreach ($key in @("inputs","outputs")) {
        if ($obj.PSObject.Properties.Name -contains $key) {
            $val = Format-Value $obj.$key
            if ($val) { $lines += "- ${key}: $val" }
        }
    }

    if ($obj.PSObject.Properties.Name -contains "files") {
        $filesVal = $obj.files
        if ($filesVal -is [System.Collections.IEnumerable] -and -not ($filesVal -is [string])) {
            $count = @($filesVal).Count
            $lines += "- files_count: $count"
        } else {
            $count = $filesVal.PSObject.Properties.Name.Count
            $lines += "- files_count: $count"
        }
    }

    $lines += ""
    return $lines
}

function Is-Excluded([string]$fullPath) {
    $exclude = @(
        "\tmp_toe_extract",
        "\tmp_toe_extract2",
        "\tmp_toe_extract3",
        "\_imports\"
    )
    foreach ($pat in $exclude) {
        if ($fullPath -like "*$pat*") { return $true }
    }
    return $false
}

$jsonFiles = @()

# 1) Top-level JSONs under data, excluding backup duplicates and tmp extracts
$jsonFiles += Get-ChildItem -Path $dataRoot -Filter "*.json" -Recurse | Where-Object {
    -not (Is-Excluded $_.FullName)
}

$jsonFiles = $jsonFiles | Sort-Object FullName

$lines = @(
    "# TOE checkpoint digest",
    "",
    "This file is generated by `scripts/toe_checkpoint_digest.ps1` and summarizes JSON checkpoints.",
    ""
)

foreach ($f in $jsonFiles) {
    $relative = $f.FullName.Replace($root + "\", "")
    $lines += Summarize-Json $f.FullName $relative
}

$outPath = Join-Path $dataRoot "_docs/toe_checkpoint_summary.md"
$lines -join "`n" | Set-Content -Path $outPath -Encoding utf8
Write-Output "Wrote $outPath"
