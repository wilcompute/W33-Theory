{
  "meta": {
    "created_utc": "2026-01-08T20:21:07.502633Z",
    "description": "Checkpoint: automorphisms of N12_58 rank6 orbit graph vs quotient; automorphisms of sector24 clock; S-distributions; generators."
  },
  "inputs": {
    "/mnt/data/N12_58_rank6_component_incidence_like_matrix.csv": {
      "sha256": "34e40a2f9b0d81e6d90b0212e9d601f73486ea2ccd9e13c20431e0023127f0e1",
      "bytes": 225
    },
    "/mnt/data/_n12/n12_58_orbit_cup_analysis.json": {
      "sha256": "e8d9fb774b5da2edbd09bd9b138776b324b04198210d8ddfe873b2d52926c262",
      "bytes": 53394
    },
    "/mnt/data/N12_58_orbit0_sector24_graph.gexf": {
      "sha256": "cea93a7fec644da198baef794b9c6e0c45420c4d4962b953389f586eabc37ad8",
      "bytes": 23823
    },
    "/mnt/data/_n12/n12_58_orbit0_state_table.csv": {
      "sha256": "8a204b604e9cea7d7898dafb0c8e243faf4a4921fb7428e88a3f2852eb09a8ac",
      "bytes": 6767
    },
    "/mnt/data/_n12/n12_58_orbit13_state_table.csv": {
      "sha256": "6308afa3caedc7bc88f50c1f4767e06a95e181b6144ff9a7f4637e5dd28df150",
      "bytes": 6828
    }
  },
  "results": {
    "rank6_component_8cell_incidence": {
      "automorphism_group_order": 1,
      "automorphisms": [
        [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ]
      ],
      "note": "Checked permutations preserving diagonal cell sizes; only identity found."
    },
    "orbit_rank6_graph_16orbits": {
      "nodes": 16,
      "edges": 38,
      "orbit_size4_nodes": [
        14,
        15
      ],
      "automorphism_group_order": 96,
      "group_order_confirmed": 96,
      "center_order": 16,
      "derived_subgroup_order": 3,
      "element_order_counts": {
        "2": 63,
        "1": 1,
        "3": 2,
        "6": 30
      },
      "structure_inference": "Matches S3 \u00d7 (Z2)^4: center order 16 (all involutions), only 2 elements of order3, 30 of order6, 63 of order2.",
      "generators": {
        "center_generators_cycles": [
          [
            [
              14,
              15
            ]
          ],
          [
            [
              3,
              9
            ]
          ],
          [
            [
              1,
              12
            ]
          ],
          [
            [
              0,
              13
            ]
          ]
        ],
        "s3_transposition_like_cycles": [
          [
            5,
            7
          ]
        ],
        "s3_3cycle_cycles": [
          [
            5,
            11,
            7
          ]
        ],
        "generated_order": 96
      }
    },
    "sector24_clock_graph": {
      "nodes": 24,
      "edges": 84,
      "automorphism_group_order": 6,
      "generator_k_shift_cycles": [
        [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        [
          6,
          7,
          8,
          9,
          10,
          11
        ],
        [
          12,
          13,
          14,
          15,
          16,
          17
        ],
        [
          18,
          19,
          20,
          21,
          22,
          23
        ]
      ],
      "generator_order": 6,
      "interpretation": "Automorphisms preserving edge labels are exactly k\u2192k+1 mod6 (Z6)."
    },
    "S_distribution": {
      "orbit0_S_counts": {
        "0": 26,
        "1": 5,
        "2": 6,
        "3": 22
      },
      "orbit13_S_counts": {
        "0": 26,
        "1": 5,
        "2": 6,
        "3": 22
      },
      "note": "Orbit0 and Orbit13 have identical S distribution; sigma=(-1)^S holds by construction."
    }
  },
  "code_summary": "# See checkpoint JSON for detailed outputs; core steps:\n# 1) Load 8x8 incidence-like matrix; brute automorphisms within diagonal-size partitions.\n# 2) Load N12_58_orbit_cup_analysis.json; build 16-orbit rank6 adjacency graph; compute automorphisms via GraphMatcher; analyze with sympy PermutationGroup.\n# 3) Load sector24 graph; compute edge-labeled automorphisms via DiGraphMatcher; find generator (k-shift).\n# 4) Load orbit0/orbit13 state tables; compute S=sum_phases_mod8/2 mod4 distributions.",
  "full_code_used": "import os, json, hashlib, itertools, math, datetime\nimport pandas as pd\nimport numpy as np\nimport networkx as nx\nfrom collections import Counter\nfrom sympy.combinatorics.permutations import Permutation\nfrom sympy.combinatorics.perm_groups import PermutationGroup\nfrom networkx.algorithms.isomorphism import GraphMatcher, DiGraphMatcher, categorical_node_match, categorical_edge_match\n\ndef sha256(path):\n    h=hashlib.sha256()\n    with open(path,'rb') as f:\n        for chunk in iter(lambda:f.read(1<<20), b''):\n            h.update(chunk)\n    return h.hexdigest()\n\ndef order_counts(G: PermutationGroup):\n    cnt=Counter()\n    for g in G.generate_schreier_sims():\n        cnt[g.order()]+=1\n    return dict(cnt)\n\ndef build_incidence_automorphisms(inc: pd.DataFrame):\n    mat=inc.values\n    diag=list(np.diag(mat))\n    classes={}\n    for i,d in enumerate(diag):\n        classes.setdefault(int(d),[]).append(i)\n    autos=[]\n    # Assume partitions exist for diag==3,2,1 as in N12_58 case.\n    for perm2 in itertools.permutations(classes.get(2,[])):\n        for perm1 in itertools.permutations(classes.get(1,[])):\n            p=[None]*len(diag)\n            # fixed unique-diagonal cells (if any)\n            for d,val in classes.items():\n                if len(val)==1 and d not in (1,2):\n                    p[val[0]]=val[0]\n            # fill diag=2 and diag=1 blocks\n            for old,new in zip(classes.get(2,[]), perm2):\n                p[old]=new\n            for old,new in zip(classes.get(1,[]), perm1):\n                p[old]=new\n            # any remaining fixed points\n            for i in range(len(p)):\n                if p[i] is None:\n                    p[i]=i\n            p=tuple(p)\n            ok=True\n            for i in range(len(diag)):\n                for j in range(len(diag)):\n                    if mat[i,j]!=mat[p[i], p[j]]:\n                        ok=False; break\n                if not ok: break\n            if ok:\n                autos.append(p)\n    return autos\n\ndef analyze_rank6_orbit_graph(cup_json_path):\n    cup=json.load(open(cup_json_path))\n    orbits=cup['missing_triangle_orbits']\n    irg=cup['orbit_rank_matrices']['intersection_rank6_graph']\n\n    G=nx.Graph()\n    for o in orbits:\n        G.add_node(o['orbit_id'], size=o['size'])\n    for u,v in irg['edges']:\n        G.add_edge(u,v)\n\n    nm=categorical_node_match(['size'], [None])\n    GM=GraphMatcher(G,G,node_match=nm)\n    isos=list(GM.isomorphisms_iter())\n    perms=[Permutation([iso[i] for i in range(16)]) for iso in isos]\n    PG=PermutationGroup(perms)\n\n    center=PG.center()\n    derived=PG.derived_subgroup()\n\n    # Find a compact generating set: 4 central involutions + one transposition-like involution + one 3-cycle\n    elts=list(PG.generate_schreier_sims())\n    id_perm=Permutation(list(range(16)))\n    Z=PermutationGroup(list(center.generate_schreier_sims()))\n    Zelts=list(Z.generate_schreier_sims())\n    Z2=[g for g in Zelts if g.order()==2]\n\n    # greedy basis for center (Z2^4)\n    center_gens=[]\n    sub=PermutationGroup([id_perm])\n    for g in Z2:\n        cand=PermutationGroup(center_gens+[g])\n        if cand.order()>sub.order():\n            center_gens.append(g); sub=cand\n        if sub.order()==center.order():\n            break\n\n    order3=[g for g in elts if g.order()==3]\n    order2=[g for g in elts if g.order()==2 and g not in Zelts]\n    g3=order3[0]\n    g3_inv=g3**-1\n    g2=None\n    for g in order2:\n        if g*g3*g == g3_inv:\n            g2=g; break\n\n    gen_set=center_gens+[g2,g3]\n    PG2=PermutationGroup(gen_set)\n\n    return {\n        \"graph_nodes\": G.number_of_nodes(),\n        \"graph_edges\": G.number_of_edges(),\n        \"size4_nodes\": [n for n,d in G.nodes(data=True) if d['size']==4],\n        \"aut_order\": len(isos),\n        \"group_order\": PG.order(),\n        \"center_order\": center.order(),\n        \"derived_order\": derived.order(),\n        \"element_order_counts\": order_counts(PG),\n        \"compact_generators\": {\n            \"center_gens_cycles\": [g.cyclic_form for g in center_gens],\n            \"s3_transposition_like_cycles\": g2.cyclic_form if g2 else None,\n            \"s3_3cycle_cycles\": g3.cyclic_form,\n            \"generated_order\": PG2.order()\n        }\n    }\n\ndef analyze_sector24_graph(gexf_path):\n    G=nx.read_gexf(gexf_path)\n    edge_match=categorical_edge_match(['delta','dk','dS'], [None,None,None])\n    GM=DiGraphMatcher(G,G, edge_match=edge_match)\n    isos=list(GM.isomorphisms_iter())\n    # pick a non-identity iso\n    iso_shift=next(iso for iso in isos if any(iso[n]!=n for n in iso))\n    nodes_sorted=sorted(G.nodes(), key=lambda s:(int(s.split(',')[0]), int(s.split(',')[1])))\n    idx={n:i for i,n in enumerate(nodes_sorted)}\n    perm=Permutation([idx[iso_shift[n]] for n in nodes_sorted])\n    return {\n        \"nodes\": G.number_of_nodes(),\n        \"edges\": G.number_of_edges(),\n        \"aut_order\": len(isos),\n        \"generator_cycles\": perm.cyclic_form,\n        \"generator_order\": perm.order()\n    }\n\nif __name__ == \"__main__\":\n    # Inputs used in the checkpoint\n    inc_path = \"N12_58_rank6_component_incidence_like_matrix.csv\"\n    cup_path = \"N12_58_orbit_cup_analysis.json\"\n    sector_path = \"N12_58_orbit0_sector24_graph.gexf\"\n    st0_path = \"N12_58_orbit0_state_table.csv\"\n    st13_path = \"N12_58_orbit13_state_table.csv\"\n\n    inc=pd.read_csv(inc_path, index_col=0)\n    autos8 = build_incidence_automorphisms(inc)\n\n    rank6 = analyze_rank6_orbit_graph(cup_path)\n    sector = analyze_sector24_graph(sector_path)\n\n    st0=pd.read_csv(st0_path); st13=pd.read_csv(st13_path)\n    st0[\"S\"]=(st0[\"sum_phases_mod8\"]//2)%4\n    st13[\"S\"]=(st13[\"sum_phases_mod8\"]//2)%4\n\n    out={\n        \"meta\":{\"created_utc\": datetime.datetime.utcnow().isoformat()+\"Z\"},\n        \"inputs\":{\n            inc_path: {\"sha256\": sha256(inc_path), \"bytes\": os.path.getsize(inc_path)},\n            cup_path: {\"sha256\": sha256(cup_path), \"bytes\": os.path.getsize(cup_path)},\n            sector_path: {\"sha256\": sha256(sector_path), \"bytes\": os.path.getsize(sector_path)},\n            st0_path: {\"sha256\": sha256(st0_path), \"bytes\": os.path.getsize(st0_path)},\n            st13_path: {\"sha256\": sha256(st13_path), \"bytes\": os.path.getsize(st13_path)},\n        },\n        \"results\":{\n            \"incidence_8cell\": {\"aut_order\": len(autos8), \"autos\": autos8[:10]},\n            \"rank6_orbit_graph\": rank6,\n            \"sector24_graph\": sector,\n            \"S_distribution\": {\n                \"orbit0\": st0[\"S\"].value_counts().sort_index().to_dict(),\n                \"orbit13\": st13[\"S\"].value_counts().sort_index().to_dict(),\n            }\n        }\n    }\n    print(json.dumps(out, indent=2))"
}
