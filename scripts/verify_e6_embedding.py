#!/usr/bin/env python3
"""Verify E6 subsystem found inside E8 by backtracking.
Reads PART_CVII_e6_in_e8_backtrack.json for node indices and verifies closure under reflections.
Writes PART_CVII_e6_in_e8_verify.json with diagnostics.
"""
import json
from pathlib import Path
import numpy as np
from itertools import product

back = Path('PART_CVII_e6_in_e8_backtrack.json')
if not back.exists():
    print('Backtrack result missing')
    raise SystemExit(1)
info = json.loads(back.read_text())
if not info:
    print('No solutions found by backtrack script')
    raise SystemExit(1)
sol = info[0]
nodes = sol['nodes']  # [a,b,c,d,e,f]
print('Using nodes:', nodes)

# Build E8 roots
E8_roots = []
import itertools
for i in range(8):
    for j in range(i+1, 8):
        for si in (-1, 1):
            for sj in (-1, 1):
                r = [0]*8
                r[i] = si
                r[j] = sj
                E8_roots.append(tuple(r))
for signs in itertools.product([-1,1], repeat=8):
    if sum(1 for s in signs if s < 0) % 2 == 0:
        r = tuple(s * 0.5 for s in signs)
        E8_roots.append(r)
E8 = np.array(E8_roots, dtype=float)

# pick simple roots
simple = np.array([E8[i] for i in nodes])
# compute Cartan
DP = E8 @ E8.T
M = np.zeros((6,6))
for i in range(6):
    for j in range(6):
        M[i,j] = 2 * (simple[i] @ simple[j]) / (simple[i] @ simple[i])
print('Cartan matrix of chosen simple roots:')
print(M)

# reflection matrices
refls = []
for i in range(6):
    alpha = simple[i]
    denom = float(alpha @ alpha)
    R = np.eye(8) - 2.0 / denom * np.outer(alpha, alpha)
    refls.append(R)

# generate group by BFS on matrix multiplication
max_iters = 100000
group = []
group_set = set()
from collections import deque

# represent matrices as tuples of rounded ints/floats
def mat_key(A):
    return tuple(map(lambda x: round(float(x), 8), A.ravel()))

queue = deque()
I = np.eye(8)
queue.append(I)
group.append(I)
group_set.add(mat_key(I))
iter_count = 0
while queue and iter_count < max_iters:
    A = queue.popleft()
    for R in refls:
        B = A @ R
        k = mat_key(B)
        if k not in group_set:
            group_set.add(k)
            queue.append(B)
            group.append(B)
    iter_count += 1

print('Group size (generated by simple reflections):', len(group))

# apply group to simple roots to get whole root system of subsystem
orbit = set()
for A in group:
    for v in simple:
        w = A @ v
        # find match among E8 roots (by approx equality)
        diffs = np.linalg.norm(E8 - w, axis=1)
        idx = int(np.argmin(diffs))
        if diffs[idx] < 1e-6:
            orbit.add(tuple(E8[idx]))

print('Orbit size from group action on simple roots:', len(orbit))

out = {
    'nodes': nodes,
    'cartan': [[float(x) for x in row] for row in M.tolist()],
    'generated_group_size': len(group),
    'orbit_size': len(orbit),
}
Path('PART_CVII_e6_in_e8_verify.json').write_text(json.dumps(out, indent=2))
print('Wrote PART_CVII_e6_in_e8_verify.json')
print(json.dumps(out, indent=2))
