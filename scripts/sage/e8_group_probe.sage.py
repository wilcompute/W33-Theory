#!/usr/bin/env sage
"""Probe Aut(W33) action on edges and compare to E8 root orbit structure.
Saves PART_CVII_e8_group_probe.json with diagnostics.
"""
from sage.all_cmdline import *   # import sage library
import json
from pathlib import Path
print('DEBUG: starting e8_group_probe')
import traceback

# Build W33: projective points PG(3,3)
F3 = GF(3)
V = VectorSpace(F3, 4)
all_nonzero = [v for v in V if v != V.zero()]

# canonical rep: scale so first nonzero entry is 1
def canonical_rep(v):
    for i in range(4):
        if v[i] != 0:
            return tuple((v / v[i]).list())
    return None

reps = sorted({canonical_rep(v) for v in all_nonzero})
assert len(reps) == 40

# adjacency via symplectic form
def symplectic_form(x, y):
    return x[0]*y[1] - x[1]*y[0] + x[2]*y[3] - x[3]*y[2]

n = len(reps)
G = Graph(n)
for i in range(n):
    vi = vector(F3, reps[i])
    for j in range(i+1, n):
        vj = vector(F3, reps[j])
        if symplectic_form(vi, vj) == 0:
            G.add_edge(i, j)

# compute automorphism group via Sp(4,3) action on projective points
print('DEBUG: computing Sp(4,3) and its action on the 40 projective points')
try:
    Sp4 = Sp(4, F3)
    aut_order = int(Sp4.order())
    print('DEBUG: Sp(4,3) order =', aut_order)
    # build permutation action of Sp4 on indices of reps
    def apply_matrix_to_rep(M, rep):
        v = vector(F3, rep)
        w = M * v
        # convert to canonical rep
        for i in range(4):
            if w[i] != 0:
                return tuple((w / w[i]).list())
        return None
    # map each group generator to a permutation
    generators = Sp4.gens()
    perms = []
    rep_index = {rep: i for i, rep in enumerate(reps)}
    for g in generators:
        perm = []
        for rep in reps:
            img = apply_matrix_to_rep(g, rep)
            if img is None or img not in rep_index:
                raise ValueError('Generator mapping failed for rep ' + str(rep))
            perm.append(rep_index[img])
        perms.append(perm)
    # build subgroup generated by permutations
    from sage.groups.perm_gps.permgroup import PermutationGroup
    Pgens = [Permutation(p) for p in perms]
    Aut = PermutationGroup(Pgens)
    print('DEBUG: permutation group constructed, order=', Aut.order())
except Exception as e:
    print('ERROR computing Sp(4,3) action:', e)
    traceback.print_exc()
    Aut = None
    aut_order = None

# edges list and mapping to indices
edges = [(u, v) for u, v in G.edges(labels=False)]
edges = sorted([tuple(sorted(e)) for e in edges])
num_edges = len(edges)

# action of automorphisms on edges: apply permutation generators (either from Aut or from raw perms list)
edge_orbits = []
seen = set()
# prepare permutation generators as callables
perm_gens = []
if 'Aut' in globals() and Aut is not None:
    try:
        for gen in Aut.generators():
            pi = gen.permutation()
            perm_gens.append(lambda a, pi=pi: int(pi(a)))
    except Exception:
        perm_gens = []
if not perm_gens and 'perms' in globals() and perms:
    # perms is list of lists mapping index -> index
    for p in perms:
        perm_gens.append(lambda a, p=p: int(p[a]))

if not perm_gens:
    print('WARNING: No permutation generators available; edge orbits will just be singletons')

try:
    for e_idx, e in enumerate(edges):
        if e_idx in seen:
            continue
        # BFS orbit
        orbit = set()
        stack = [e]
        while stack:
            cur = stack.pop()
            if cur in orbit:
                continue
            orbit.add(cur)
            # apply all permutation generators
            for pi_func in perm_gens:
                a, b = cur
                na = pi_func(a)
                nb = pi_func(b)
                mapped = tuple(sorted((int(na), int(nb))))
                if mapped not in orbit:
                    stack.append(mapped)
        # mark indices
        idxs = [edges.index(tuple(sorted(o))) for o in orbit]
        for ii in idxs:
            seen.add(ii)
        edge_orbits.append({'size': len(orbit), 'repr': sorted(list(orbit))[0]})
except Exception as e:
    print('ERROR during edge orbit computation:', e)
    traceback.print_exc()
    edge_orbits = [{'size': 1, 'repr': e} for e in edges]

edge_orbits_sorted = sorted(edge_orbits, key=lambda x: -x['size'])

# E8 root system
E8 = RootSystem(['E',8])
E8_roots = list(E8.root_lattice().roots())
# Convert roots to vectors in QQ or RR
E8_vecs = [r.to_vector() for r in E8_roots]
# get norms squared
norms = [v.norm()**2 for v in E8_vecs]
norms_set = sorted(list(set(norms)))

# Weyl group
W_E8 = E8.weyl_group()
w_e8_order = W_E8.order()

# orbit stats of roots under Weyl group (should be a single orbit for roots)
# We'll compute root orbit via action of Weyl group generators acting on root lattice
root_orbit = set()
stack = [E8_vecs[0]]
while stack:
    v = stack.pop()
    key = tuple([int(c) for c in v])
    if key in root_orbit:
        continue
    root_orbit.add(key)
    for g in W_E8.simple_reflections():
        v2 = g.action(v)
        key2 = tuple([int(c) for c in v2])
        if key2 not in root_orbit:
            stack.append(v2)

# sanity
num_roots = len(E8_roots)
root_orbit_size = len(root_orbit)

out = {
    'aut_order': int(aut_order),
    'num_vertices': int(n),
    'num_edges': int(num_edges),
    'edge_orbit_sizes': [o['size'] for o in edge_orbits_sorted],
    'edge_orbit_reprs': [o['repr'] for o in edge_orbits_sorted],
    'e8_num_roots': int(num_roots),
    'e8_root_orbit_size': int(root_orbit_size),
    'e8_weyl_order': int(w_e8_order),
    'e8_root_norms_set': [int(x) for x in norms_set],
}

Path('PART_CVII_e8_group_probe.json').write_text(json.dumps(out, indent=2))
print('Wrote PART_CVII_e8_group_probe.json')
print(json.dumps(out, indent=2))
